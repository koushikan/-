
compose
f3(f2(f1)) 这样的叫做函数组合  f(g(h(1)))  f.g.h 1  

compose(f,g,h)

const compose = (...funcs) => {
   return funcs.reduceRight( (f1,f2) => (...arg) => f2(f1(...arg)) )
}

一阶compose  下一函数的参数是上一函数的结果
const f1 = a => a * 1
const f2 = a => a * 2
console.log(  compose(f2,f1)(1) )    //f2(f1(1))


二阶compose  下函数的参数是上一函数传递进来的


const f1 = next => arg => next(arg * 1)
const f2 = next => arg => next(arg * 2)
const f3 = next => arg => next(arg * 3)

f2(f1) = arg => f1(arg * 2)
f3(f2(f1)) = arg1 => (arg => f1(arg * 2))(arg1 * 3)  // eta变化  参数计算
           = arg1 =>  f1(arg1 * 3 * 2)   // aerfa变化  参数名称不重要
           = arg  =>  f1(arg * 3 * 2)
           
           
console.log(  compose(f2,f1)(a => a)(1) )
这种二阶compose是不是很熟悉? 很多中间件模式 都采用这种套路

